assume cs:code,ds:data,ss:stack

data segment

        db 'welcome to masm!'  ;定义要显示的字符串(共16字节)

        db 0CAh,24h,71h    ;定义三种颜色属性

data ends

stack segment

        dw 8 dup(0)

stack ends

code segment

start:

        mov ax,data

        mov ds,ax

        mov ax,stack

        mov ss,ax

        mov sp,10h

        mov bx,0

        mov di,0

        mov ax,0b872h    ;算出屏幕第12行中间的显存的段起始位置放入ax中

        mov cx,3     ;外循环为3次，因为要显示三个字符串

s3:     push cx        ;三个进栈操作为外循环s3保存相关寄存器的值

        push ax        ;以防止它们的值在内循环中被破坏

        push di

        mov es,ax      ;此时es为屏幕第12行中间的显存的段起始位置

        mov si,0

        mov di,0

        mov cx,10h     ;内循环为10h次，因为一个字符串中含10h个字节

s1:     mov al,ds:[bx+si]

        mov es:[bx+di],al

        inc si

        add di,2

        loop s1      ;此循环实现偶地址中存放字符

        mov si,1   ;si的值设为1,从而为在显存奇地址中存放字符的颜色属性做准备

        pop di        ;将di的值恢复成进入内循环之前的时候的值

        mov al,ds:10h[bx+di]    ;取颜色属性[源OP寻址方式：相对基址变址]

        mov cx,10h     ;第二个内循环也为10h次

s2:     mov es:[bx+si],al

        add si,2

        loop s2       ;此循环实现奇地址中存放字符的颜色属性

        ;以下4句为下一趟外循环做准备

        inc di

        pop ax

        add ax,0ah   ;将显存的段起始地址设为当前行的下一行

                  ;[在段地址中加0ah,相当于在偏移地址中加了0a0h(=160d)]

        pop cx

        loop s3

        mov ax,4c00h

        int 21h

code ends

end start
